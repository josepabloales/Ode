{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tarea 4: Documentaci\u00f3n de c\u00f3digo y Git","text":""},{"location":"#estudiantes-jose-pablo-alvarado-mateo-heinz-ana-laura-viquez","title":"Estudiantes: Jos\u00e9 Pablo Alvarado, Mateo Heinz, Ana Laura V\u00edquez","text":""},{"location":"#metodos-de-resolucion-numerica-de-ecuaciones-diferenciales-ordinarias","title":"M\u00e9todos de resoluci\u00f3n num\u00e9rica de ecuaciones diferenciales ordinarias","text":""},{"location":"#1-metodo-de-euler","title":"1) M\u00e9todo de Euler","text":"<p>El m\u00e9todo de Euler se basa en la expansi\u00f3n de Taylor de la funci\u00f3n \\(x(t)\\): $$ \\text{Expansi\u00f3n Taylor} \\Rightarrow x(t+h) = x(t) + h\\frac{dx}{dt} + \\overbrace{ \\frac{h^2}{2} \\frac{d^2x}{dt^2} } ^{\\epsilon} + O(h^3). $$ Se evalua la funci\u00f3n x en un tiempo t m\u00e1s un \\(h\\) suficientemente peque\u00f1o: $$ \\boxed{x(t + h) = x(t) + hf(x,t).} $$ Esta ecuaci\u00f3n da una aproximaci\u00f3n relacionada con el n\u00famero de pasos en el tiempo que utilicemos para llegar a ella y el error asociado con la aproximaci\u00f3n tambi\u00e9n esta determinado por este n\u00famero de pasos como se muestra en la siguiente ecuaci\u00f3n:</p> \\[ \\sum\\epsilon = \\sum_{k=0}^{N-1}\\frac{h^2}{2}\\left. \\frac{d^2x}{dt^2} \\right|_{x_k, t_k} = \\frac{h}{2}\\sum_{k=0}^{N-1}h\\left.\\frac{df}{dt}\\right|_{x_k, t_k}\\\\ \\] <p>$$ \\approx \\frac{h}2\\int_a^b\\frac{df}{dt}d t = \\frac{h}{2}\\left[f_b - f_a\\right]. $$ En la ecuaci\u00f3n anterior se asume que se toma \\(N = (b-a)/h\\) pasos temporales para llegar al punto final.</p> <p>El error total de aproximaci\u00f3n depende \\(h\\) linealmente multiplicado por el intervalo en el cual realizamos la integraci\u00f3n.</p> <ul> <li>Para algunas aplicaciones, esto es suficiente. Para otras, necesitamos una mejor aproximaci\u00f3n.</li> <li>El algoritmo toma la siguiente forma:</li> <li>Empezar con \\(t = t_0\\), \\(x = x_0\\)</li> <li>Discretizar el tiempo en pasos temporales de forma equidistante con espaciamiento \\(h\\), donde cada punto en el tiempo est\u00e1 denotado con \\(t_i\\)</li> <li>Para cada punto en el tiempo encontrar \\(x\\) utilizando el resultado de la iteraci\u00f3n previa: \\(x_i = x_{i-1} + hf(x_{i-1})\\)</li> </ul>"},{"location":"#2-metodo-de-runge-kutta","title":"2) M\u00e9todo de Runge-Kutta","text":""},{"location":"#rk2","title":"Rk2","text":"<p>La idea del m\u00e9todo RK2 es utilizar el punto medio para evaluar el m\u00e9todo de Euler, como se indica en la figura. Mientras que el m\u00e9todo de Euler se aplica en el punto \\(t\\) para evaluar la derivada para aproximar la funci\u00f3n en el punto \\(x = t + h\\), el m\u00e9todo RK2 utiliza el punto medio \\(t + h/2\\). </p> <p>De esta forma, se alcanza una mejor aproximaci\u00f3n para el mismo valor de \\(h\\).</p> <p>El m\u00e9todo se deriva aplicando la serie de Taylor alrededor del punto medio \\(t + h/2\\) para obtener el valor de la funci\u00f3n en el punto \\(x(t + h)\\). Tenemos:</p> \\[ x(t + h) = x\\left(t + \\frac{h}{2}\\right) + \\frac{h}{2}\\left(\\frac{{\\rm d}x}{{\\rm d}t}\\right)_{t+h/2} + \\frac{h^2}{8}\\left(\\frac{{\\rm d}^2x}{{\\rm d}t^2}\\right)_{t+h/2} + O(h^3) \\] <p>Similarmente, podemos hacer lo mismo para \\(x(t)\\), tal que:</p> \\[ x(t) = x\\left(t + \\frac{h}{2}\\right) - \\frac{h}{2}\\left(\\frac{{\\rm d}x}{{\\rm d}t}\\right)_{t+h/2} + \\frac{h^2}{8}\\left(\\frac{{\\rm d}^2x}{{\\rm d}t^2}\\right)_{t+h/2} + O(h^3) \\] <p>Al sustraer ambas ecuaciones obtenemos $$ x(t + h) = x(t) + h\\left(\\frac{{\\rm d}x}{{\\rm d}t}\\right)_{t+h/2} + O(h^3) $$</p> <p>Finalmente, $$ \\boxed{x(t + h) = x(t) + hf[x(t + h/2), t + h/2] + O(h^3)}. $$</p> <p>El t\u00e9rmino de orden \\(h^2\\) desaparece y nuestra aproximaci\u00f3n tiene un error de orden \\(h^3\\). Recordemos que incrementar el orden del error por un orden de magnitud es muy beneficioso a nivel computacional. </p> <p>El \u00fanico problema es que requerimos conocer el valor de la funci\u00f3n en el punto medio \\(x(t + h/2)\\), el cual desconocemos.</p> <p>Para aproximar este valor utilizamos el m\u00e9todo de Euler con un paso \\(h/2\\), \\((x + h/2) = x(t) + \\frac{h}{2}f(x,t)\\). De esta manera, obtenemos las ecuaciones del m\u00e9todo RK2:</p> <ul> <li>\\(k_1 = hf(x,t),\\)</li> <li>\\(k_2 = hf\\left(x + \\frac{k_1}{2},t + \\frac{h}{2}\\right)\\)</li> <li>\\(x(t + h) = x(t) + k_2\\) El error de aproximaci\u00f3n de cada paso es de orden \\(O(h^3)\\), mientras que el error global (con un an\u00e1lisis similar al que hicimos con el m\u00e9todo de Euler) es de order \\(O(h^2)\\). </li> </ul> <p>Cabe recalcar que al utilizar el m\u00e9todo de Euler para la primera parte de la aproximaci\u00f3n, el error tambi\u00e9n es de \\(O(h^3)\\) y por ende el error de aproximaci\u00f3n se mantiene de \\(O(h^3)\\).</p>"},{"location":"#rk4","title":"Rk4","text":"<p>Este m\u00e9todo es igual al RK2 pero se toman en vez de 2 valores \\(h_1\\) y \\(h_2\\), 4 valores \\(h_1\\), \\(h_2\\), \\(h_3\\) y \\(h_4\\). Y estos valores determinan la ecuaci\u00f3n \\(x(t+h)\\) de una mejor manera, haciendo la aproximaci\u00f3n m\u00e1s exacta y convergiendo m\u00e1s r\u00e1pido al resultado real de la ecuaci\u00f3n diferencial.</p> <p>Los valores de \\(h_n\\) son:</p> <ul> <li>\\(k_1 = hf(x, t)\\),</li> <li>\\(k_2 = hf\\left(x + \\frac{k_1}{2}, t+\\frac{h}2\\right)\\),</li> <li>\\(k_3 = hf\\left(x + \\frac{k_2}{2}, t+\\frac{h}2\\right)\\),</li> <li>\\(k_4 = hf\\left(x + k_3, t + h \\right)\\),</li> <li>\\(x(t+h) = x(t) + \\frac{1}{6}(k_1 + 2 k_2 + 2k_3 + k_4)\\).</li> </ul> <p>Generalmente este es el mejor m\u00e9todo para programar soluciones a ecuaciones diferenciales por su facilidad de programaci\u00f3n y la precision de sus resultados. </p> <p>El error de aproximaci\u00f3n es \\(O(h^5)\\), mientras que el error global es aproximadamente del orden \\(O(h^4)\\).</p>"},{"location":"reference/","title":"Reference","text":"<p>Se tiene la ecuaci\u00f3n diferencial:</p> <p>$$ \\frac{{\\rm d}x}{{\\rm d}t} = -x^3 + \\sin(t), $$ con la condici\u00f3n inicial \\(x(0) = 0\\) desde \\(t = 0\\) hasta \\(t = 10\\).</p> <p>Y se va resolver mediante los m\u00e9todos num\u00e9ricos: Euler, RK2 y RK4. Entonces lo primero es definir una funci\u00f3n que va a corresponder a la ecuaci\u00f3n diferencial a resolver y luego definir 3 funciones que son las de Euler, RK2 y RK4 para resolver dicha ecuaci\u00f3n.</p>"},{"location":"reference/#ode.ode.RK2","title":"<code>RK2(t0, x0, tn, n)</code>","text":"<p>M\u00e9todo de Runge-Kutta de 2 orden para resolver ecuaciones diferenciales ordinarias.</p> <p>Parameters:</p> Name Type Description Default <code>t0</code> <code>float</code> <p>Primer argumento (el valor de la condici\u00f3n inicial de la variable t)</p> required <code>x0</code> <code>float</code> <p>Segundo argumento (el valor de la condici\u00f3n inicial de la variable x)</p> required <code>tn</code> <code>float</code> <p>Tercer argumento (el valor de la condici\u00f3n de frontera de la variable t)</p> required <code>n</code> <code>int</code> <p>Cuarto argumento (el n\u00famero de pasos o iteraciones que se van a utilizar para resolver la ED)</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; euler(0, 0, 10, 8)\n(array([ 0.  ,  1.25,  2.5 ,  3.75,  5.  ,  6.25,  7.5 ,  8.75, 10.  ]), array([ 0.        ,  0.73137159,  0.34943373, -0.05274473, -1.14619757,\n</code></pre> <p>-1.26024028, -0.56287143,  0.63843778, -0.11188799]))</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>2 arreglos, el primero de los n+1 valores de la variable t y el segundo de los n+1 valores de la variable t; en el intervalo [t0,tn]</p> Source code in <code>ode/ode.py</code> <pre><code>def RK2(t0, x0, tn, n):\n    \"\"\"M\u00e9todo de Runge-Kutta de 2 orden para resolver ecuaciones diferenciales ordinarias.\n\n    Args:\n        t0 (float): Primer argumento (el valor de la condici\u00f3n inicial de la variable t)\n        x0 (float): Segundo argumento (el valor de la condici\u00f3n inicial de la variable x)\n        tn (float): Tercer argumento (el valor de la condici\u00f3n de frontera de la variable t)\n        n (int): Cuarto argumento (el n\u00famero de pasos o iteraciones que se van a utilizar para resolver la ED)\n\n    Examples:\n        &gt;&gt;&gt; euler(0, 0, 10, 8)\n        (array([ 0.  ,  1.25,  2.5 ,  3.75,  5.  ,  6.25,  7.5 ,  8.75, 10.  ]), array([ 0.        ,  0.73137159,  0.34943373, -0.05274473, -1.14619757,\n       -1.26024028, -0.56287143,  0.63843778, -0.11188799]))\n\n    Returns:\n        tuple: 2 arreglos, el primero de los n+1 valores de la variable t y el segundo de los n+1 valores de la variable t; en el intervalo [t0,tn]\n\n\n    \"\"\"\n    h = (tn-t0)/float(n)\n    t = np.linspace(t0, tn, n+1)\n    x = np.zeros(n+1)\n    x[0] = x0\n    for i in range(n):\n        k1 = h * f(t[i], x[i])\n        k2 = h * f(t[i] + 0.5*h, x[i] + 0.5*k1)\n        x[i+1] = x[i] + k2\n        x_aprox = x[i+1]\n        x_n = x[i]\n    return (t, x)\n</code></pre>"},{"location":"reference/#ode.ode.RK4","title":"<code>RK4(t0, x0, tn, n)</code>","text":"<p>M\u00e9todo de Runge-Kutta de 4 orden para resolver ecuaciones diferenciales ordinarias.</p> <p>Parameters:</p> Name Type Description Default <code>t0</code> <code>float</code> <p>Primer argumento (el valor de la condici\u00f3n inicial de la variable t)</p> required <code>x0</code> <code>float</code> <p>Segundo argumento (el valor de la condici\u00f3n inicial de la variable x)</p> required <code>tn</code> <code>float</code> <p>Tercer argumento (el valor de la condici\u00f3n de frontera de la variable t)</p> required <code>n</code> <code>int</code> <p>Cuarto argumento (el n\u00famero de pasos o iteraciones que se van a utilizar para resolver la ED)</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; euler(0, 0, 10, 8)\n(array([ 0.  ,  1.25,  2.5 ,  3.75,  5.  ,  6.25,  7.5 ,  8.75, 10.  ]), array([ 0.        ,  0.60218291,  0.15942164,  0.11425799, -0.77075997,\n</code></pre> <p>-0.16900616,  0.45613153,  0.37341583,  0.23954224]))</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>2 arreglos, el primero de los n+1 valores de la variable t y el segundo de los n+1 valores de la variable t; en el intervalo [t0,tn]</p> Source code in <code>ode/ode.py</code> <pre><code>def RK4(t0, x0, tn, n):\n    \"\"\"M\u00e9todo de Runge-Kutta de 4 orden para resolver ecuaciones diferenciales ordinarias.\n\n    Args:\n        t0 (float): Primer argumento (el valor de la condici\u00f3n inicial de la variable t)\n        x0 (float): Segundo argumento (el valor de la condici\u00f3n inicial de la variable x)\n        tn (float): Tercer argumento (el valor de la condici\u00f3n de frontera de la variable t)\n        n (int): Cuarto argumento (el n\u00famero de pasos o iteraciones que se van a utilizar para resolver la ED)\n\n    Examples:\n        &gt;&gt;&gt; euler(0, 0, 10, 8)\n        (array([ 0.  ,  1.25,  2.5 ,  3.75,  5.  ,  6.25,  7.5 ,  8.75, 10.  ]), array([ 0.        ,  0.60218291,  0.15942164,  0.11425799, -0.77075997,\n       -0.16900616,  0.45613153,  0.37341583,  0.23954224]))\n\n    Returns:\n        tuple: 2 arreglos, el primero de los n+1 valores de la variable t y el segundo de los n+1 valores de la variable t; en el intervalo [t0,tn]\n\n    \"\"\"\n    h = (tn-t0)/float(n)\n    t = np.linspace(t0, tn, n+1)\n    x = np.zeros(n+1)\n    x[0] = x0\n    for i in range(n):\n        k1 = h * f(t[i], x[i])\n        k2 = h * f(t[i] + 0.5*h, x[i] + 0.5*k1)\n        k3 = h * f(t[i] + 0.5*h, x[i] + 0.5*k2)\n        k4 = h * f(t[i] + h, x[i] + k3)\n        x[i+1] = x[i] + (k1 + 2*k2 + 2*k3 + k4)/6\n        x_aprox = x[i+1]\n        x_n = x[i]\n    return (t, x)\n</code></pre>"},{"location":"reference/#ode.ode.euler","title":"<code>euler(t0, x0, tn, n)</code>","text":"<p>M\u00e9todo de Euler para resolver ecuaciones diferenciales ordinarias.</p> <p>Parameters:</p> Name Type Description Default <code>t0</code> <code>float</code> <p>Primer argumento (el valor de la condici\u00f3n inicial de la variable t)</p> required <code>x0</code> <code>float</code> <p>Segundo argumento (el valor de la condici\u00f3n inicial de la variable x)</p> required <code>tn</code> <code>float</code> <p>Tercer argumento (el valor de la condici\u00f3n de frontera de la variable t)</p> required <code>n</code> <code>int</code> <p>Cuarto argumento (el n\u00famero de pasos o iteraciones que se van a utilizar para resolver la ED)</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; euler(0, 0, 10, 8)\n(array([ 0.  ,  1.25,  2.5 ,  3.75,  5.  ,  6.25,  7.5 ,  8.75, 10.  ]), array([ 0.        ,  0.        ,  1.18623077, -0.15217513, -0.86222182,\n</code></pre> <p>-1.25962901,  1.19715891,  0.22496448,  0.99163788]))</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>2 arreglos, el primero de los n+1 valores de la variable t y el segundo de los n+1 valores de la variable t; en el intervalo [t0,tn]</p> Source code in <code>ode/ode.py</code> <pre><code>def euler(t0, x0, tn, n):\n    \"\"\"M\u00e9todo de Euler para resolver ecuaciones diferenciales ordinarias.\n\n    Args:\n        t0 (float): Primer argumento (el valor de la condici\u00f3n inicial de la variable t)\n        x0 (float): Segundo argumento (el valor de la condici\u00f3n inicial de la variable x)\n        tn (float): Tercer argumento (el valor de la condici\u00f3n de frontera de la variable t)\n        n (int): Cuarto argumento (el n\u00famero de pasos o iteraciones que se van a utilizar para resolver la ED)\n\n    Examples:\n        &gt;&gt;&gt; euler(0, 0, 10, 8)\n        (array([ 0.  ,  1.25,  2.5 ,  3.75,  5.  ,  6.25,  7.5 ,  8.75, 10.  ]), array([ 0.        ,  0.        ,  1.18623077, -0.15217513, -0.86222182,\n       -1.25962901,  1.19715891,  0.22496448,  0.99163788]))\n\n    Returns:\n        tuple: 2 arreglos, el primero de los n+1 valores de la variable t y el segundo de los n+1 valores de la variable t; en el intervalo [t0,tn]\n    \"\"\"\n    h = (tn-t0)/float(n)\n    t = np.linspace(t0, tn, n+1)\n    x = np.zeros(n+1)\n    x[0] = x0\n    for i in range(n):\n        x[i + 1] = x[i] + h*f(t[i], x[i])\n    return (t,x)\n</code></pre>"},{"location":"reference/#ode.ode.f","title":"<code>f(t, x)</code>","text":"<p>La ecuaci\u00f3n diferencial (ED) dx/dt a resolver.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>First argument, la variable independiente de la ED</p> required <code>x</code> <code>float</code> <p>Second argument, la variable dependiente de la ED</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; f(1.0, 2.0)\n-7.158529015192103\n</code></pre> <p>Returns:</p> Name Type Description <code>float</code> <p>Retorna el resultado de la operaci\u00f3n -x**(3) + np.sin(t).</p> Source code in <code>ode/ode.py</code> <pre><code>def f(t, x):\n    \"\"\"La ecuaci\u00f3n diferencial (ED) dx/dt a resolver.\n\n    Args:\n        t (float): First argument, la variable independiente de la ED\n        x (float): Second argument, la variable dependiente de la ED\n\n    Examples:\n        &gt;&gt;&gt; f(1.0, 2.0)\n        -7.158529015192103\n\n    Returns:\n        float: Retorna el resultado de la operaci\u00f3n -x**(3) + np.sin(t).\n\n    \"\"\"\n    return (-x**(3) + np.sin(t))\n</code></pre>"}]}